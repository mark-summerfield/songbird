src/songbird.pyw
src/MainWindow.py
src/FileActions.py
src/EditActions.py
src/ContentsActions.py
# src/SQLActions.py
src/OptionsActions.py
# src/WindowsActions.py
src/HelpActions.py
src/ContentsView.py
src/PragmaView.py
src/Ui.py
src/TableWidget.py # TODO
src/TableModel.py # TODO
src/Model.py
src/Sql.py
src/RecentFiles.py
src/Config.py
src/Const.py

st.sh

README.md

# TODO
# Replace TableWidget and TableModel with SelectWidget and SelectModel
# that takes an arbitrary SQL SELECT (which it should show; so need to
# add a QPlainTextEdit as the top widget in a vbox of 3). For tables the
# default SQL is 'SELECT * FROM {name}'; for view extract the sql from
# the sqlite_master table and delete the leading 'CREATE VIEW ... AS'
# with the rest being the SELECT, e.g.,
#   'CREATE VIEW stations_with_kiosks as select stations.id,
#   stations.name, stations.zone, kiosks.name from stations, kiosks
#   where stations.id = kiosks.sid'
# Then add the buttons and voila, I'll have the list view part of the
# QueryWidget described below...

# - create QueryWidget (to show: ad hoc SELECT, Table, View)
#     -- list view --
#   QPlainTextEdit + QSyntaxHighlighter to show raw SQL
#   -- splitter --
#   QTableView with custom QueryModel (using OFFSET & LIMIT if rows > 1K)
#   -- splitter --
#   QPlainTextEdit for errors & info
#   [Insert][Update][Delete][Form View] # saves when any clicked
#      -- form view --
#   QLabel1 editor1
#	:
#   QLabelN editorN
#   [Insert][Update][Delete][List View][Previous][Next] # saves when any clicked
#
# - src/QueryModel.py # TODO implement my own using:
#   & SELECT COUNT(*) FROM (<user query>)
#   & if <user query> doesn't use LIMIT and count > 1K
#   (user option) then 
#   SELECT <user query> LIMIT :chunk_size OFFSET :offset
#
# - create TriggerEditor for adding/editing/deleting triggers
#
# - create IndexEditor for adding/editing/deleting indexes
#
# - complete menus: File (Edit) Contents SQL Options Windows[SDI] Help
# - pure SQL
# - options dialog:
#   default suffix; default database (SQLite | Songbird);
#   [X] Show Row Numbers (in list views)
# - custom types using songbird_types (tablename, fieldname, type)
# - custom forms
# - See DB Browser for SQLite's Tools menu (Optimize, Check, etc.)
# - See DB Browser for SQLite's File menu & Edit→Preferences dialog
# - provide an editor/dialog/? for creating transforms e.g., applying
#   some math function to every column in a table (or selection of a
#   table), etc.
# - Songbird:
#   . File→New Songbird
#   . songbird_types (tablename, fieldname, tid, minimum, maximum)
#     tid "type ID", e.g., 1 Boolean, 2 Integer, ...
#   . songbird_windows (tablename, x, y, width, height, z, tab_pos,
#     sql_select, listview) -- sql is the SELECT; listview is Boolean
#     list or form view
#   . songbird_config (key, value) e.g., show_contents, show_pragmas,
#     use tabs (vs MDI) etc.
# - ultimately aim to be able to replace both Biller and Notebox with
#  custom songbird databases

# Toggle Form View toggles between a form for adding/editing and a list
# for viewing (and possibly in-place adding/editing).
# Toggle Tabs toggles between MDI and tabs view.

# SQL->Create Query leads to a dialog for creating:
# - a raw SQL query
# - SELECT|INSERT|UPDATE|DELETE using using a wizard
# - applying some kind of transform using a wizard
# The result is added to the contents view and added as an MDI window

# &SQL                
#   Create &Query...
#   ---------         
#   Create &Table...  
#   Create &View...  
#   &Create Trigger...
#   ---------        
#   &Alter Table...  
#   Alter Vie&w...   
#   A&lter Trigger...

# &Window # SDI! (max of 9)
#   &1 <sdi name>        
#      :	         
#   &9 <sdi name>        

# Initially insert/update can only be done in form view and delete in
# form or list view. Ideally allow in-place insert/update in list view
# if/when possible.

# Ideas
#  - implement Undo/Redo by using a temporary memory database; see
#    https://www.sqlite.org/undoredo.html

# vim: syn=yaml
